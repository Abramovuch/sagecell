// Generated by CoffeeScript 1.5.0
(function() {
  var SalvusThreeJS, component_to_hex, defaults, required, rgb_to_hex, root, run_when_defined, to_json,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  to_json = function(x) {
    return JSON.stringify(x);
  };

  defaults = function(obj1, obj2) {
    var error, prop, r, val;
    if (obj1 == null) {
      obj1 = {};
    }
    error = function() {
      try {
        return "(obj1=" + (to_json(obj1)) + ", obj2=" + (to_json(obj2)) + ")";
      } catch (error) {
        return "";
      }
    };
    if (typeof obj1 !== 'object') {
      console.trace();
      throw "misc.defaults -- TypeError: function takes inputs as an object " + (error());
    }
    r = {};
    for (prop in obj2) {
      val = obj2[prop];
      if (obj1.hasOwnProperty(prop) && (obj1[prop] != null)) {
        if (obj2[prop] === defaults.required && (obj1[prop] == null)) {
          console.trace();
          throw "misc.defaults -- TypeError: property '" + prop + "' must be specified: " + (error());
        }
        r[prop] = obj1[prop];
      } else if (obj2[prop] != null) {
        if (obj2[prop] === defaults.required) {
          console.trace();
          throw "misc.defaults -- TypeError: property '" + prop + "' must be specified: " + (error());
        } else {
          r[prop] = obj2[prop];
        }
      }
    }
    for (prop in obj1) {
      val = obj1[prop];
      if (!obj2.hasOwnProperty(prop)) {
        console.trace();
        throw "misc.defaults -- TypeError: got an unexpected argument '" + prop + "' " + (error());
      }
    }
    return r;
  };

  required = defaults.required = "__!!!!!!this is a required property!!!!!!__";

  /* END misc.coffee includes
  */


  run_when_defined = function(opts) {
    var delay, f, total;
    opts = defaults(opts, {
      fn: required,
      start_delay: 100,
      max_time: 10000,
      exp_factor: 1.4,
      cb: required,
      err: required
    });
    delay = void 0;
    total = 0;
    f = function() {
      var result;
      result = opts.fn();
      if (result != null) {
        return opts.cb(result);
      } else {
        if (delay == null) {
          delay = opts.start_delay;
        } else {
          delay *= opts.exp_factor;
        }
        total += delay;
        if (total > opts.max_time) {
          return opts.err("failed to eval code within " + opts.max_time);
        } else {
          return setTimeout(f, delay);
        }
      }
    };
    return f();
  };

  component_to_hex = function(c) {
    var hex;
    hex = c.toString(16);
    if (hex.length === 1) {
      return "0" + hex;
    } else {
      return hex;
    }
  };

  rgb_to_hex = function(r, g, b) {
    return "#" + component_to_hex(r) + component_to_hex(g) + component_to_hex(b);
  };

  SalvusThreeJS = (function() {

    function SalvusThreeJS(opts) {
      this.render_scene = __bind(this.render_scene, this);
      this.controlChange = __bind(this.controlChange, this);
      this.update_rotating_lights = __bind(this.update_rotating_lights, this);
      this.animate = __bind(this.animate, this);
      this.set_frame = __bind(this.set_frame, this);
      this.add_3dgraphics_obj = __bind(this.add_3dgraphics_obj, this);
      this.make_object = __bind(this.make_object, this);
      this.make_index_face_set = __bind(this.make_index_face_set, this);
      this.make_group = __bind(this.make_group, this);
      this.make_sphere = __bind(this.make_sphere, this);
      this.make_point = __bind(this.make_point, this);
      this.make_line = __bind(this.make_line, this);
      this.make_text = __bind(this.make_text, this);
      this.make_wireframe_material = __bind(this.make_wireframe_material, this);
      this.make_phong_material = __bind(this.make_phong_material, this);
      this.make_lambert_material = __bind(this.make_lambert_material, this);
      this.make_spot_light = __bind(this.make_spot_light, this);
      this.make_point_light = __bind(this.make_point_light, this);
      this.make_directional_light = __bind(this.make_directional_light, this);
      this.make_ambient_light = __bind(this.make_ambient_light, this);
      this.add_lights = __bind(this.add_lights, this);
      this.add_camera = __bind(this.add_camera, this);
      this.set_trackball_controls = __bind(this.set_trackball_controls, this);
      this.data_url = __bind(this.data_url, this);
      var a, c, i, z;
      this.opts = defaults(opts, {
        element: required,
        width: void 0,
        height: void 0,
        renderer: void 0,
        trackball: true,
        light: true,
        background: void 0,
        foreground: void 0,
        camera_distance: 10
      });
      this.scene = new THREE.Scene();
      this.opts.width = opts.width != null ? opts.width : $(window).width() * .9;
      this.opts.height = opts.height != null ? opts.height : $(window).height() * .6;
      if (this.opts.renderer == null) {
        if (Detector.webgl) {
          this.opts.renderer = 'webgl';
        } else {
          this.opts.renderer = 'canvas2d';
        }
      }
      if (this.opts.renderer === 'webgl') {
        this.opts.element.find(".salvus-3d-viewer-renderer").text("webgl");
        this.renderer = new THREE.WebGLRenderer({
          antialias: true,
          preserveDrawingBuffer: true
        });
      } else {
        this.opts.element.find(".salvus-3d-viewer-renderer").text("canvas2d");
        this.renderer = new THREE.CanvasRenderer({
          antialias: true
        });
      }
      this.renderer.setSize(this.opts.width, this.opts.height);
      this.renderer.setClearColor(0xffffff, 1);
      if (this.opts.background == null) {
        this.opts.background = "rgba(1,1,1,0);";
        if (this.opts.foreground == null) {
          this.opts.foreground = "#000000";
        }
      }
      this.opts.element.find(".salvus-3d-canvas").css({
        'background': this.opts.background
      }).append($(this.renderer.domElement));
      if (this.opts.foreground == null) {
        c = this.opts.element.find(".salvus-3d-canvas").css('background');
        i = c.indexOf(')');
        z = (function() {
          var _i, _len, _ref, _results;
          _ref = c.slice(4, i).split(',');
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            a = _ref[_i];
            _results.push(255 - parseInt(a));
          }
          return _results;
        })();
        this.opts.foreground = rgb_to_hex(z[0], z[1], z[2]);
      }
      this._center = this.scene.position;
      this.add_camera({
        distance: this.opts.camera_distance
      });
      if (this.opts.trackball) {
        this.set_trackball_controls();
      }
      this.lights = {
        "static": [],
        rotating: [],
        camera_distance: this.camera.position.distanceTo(this._center)
      };
      this.controls.addEventListener('change', this.controlChange);
      this._animate = false;
      this._animation_frame = false;
      window.MYSCENE = this;
      this.three = THREE;
    }

    SalvusThreeJS.prototype.data_url = function(type) {
      if (type == null) {
        type = 'png';
      }
      return this.renderer.domElement.toDataURL("image/" + type);
    };

    SalvusThreeJS.prototype.set_trackball_controls = function() {
      /*
      # other options: rotate object instead of camera
      # see: https://github.com/mrdoob/three.js/issues/1220#issuecomment-3753576
      # see: https://github.com/mrdoob/three.js/issues/781
      */

      var _this = this;
      if (this.controls != null) {
        return;
      }
      this.controls = new THREE.TrackballControls(this.camera, this.renderer.domElement);
      this.controls.dynamicDampingFactor = 0.3;
      this.controls.noRoll = true;
      if (this._center != null) {
        this.controls.target = this._center;
      }
      this.controls.addEventListener('change', this.controlChange);
      this.controls.addEventListener('start', (function() {
        _this._animate = true;
        return _this._animation_frame = requestAnimationFrame(_this.animate);
      }));
      return this.controls.addEventListener('end', (function() {
        return _this._animate = false;
      }));
    };

    SalvusThreeJS.prototype.add_camera = function(opts) {
      var aspect, far, near, view_angle;
      opts = defaults(opts, {
        distance: 10
      });
      view_angle = 45;
      aspect = this.opts.width / this.opts.height;
      near = 0.1;
      far = Math.max(20000, opts.distance * 2);
      this.camera = new THREE.PerspectiveCamera(view_angle, aspect, near, far);
      this.scene.add(this.camera);
      this.camera.position.set(opts.distance, opts.distance, opts.distance);
      this.camera.lookAt(this.scene.position);
      this.camera.up = new THREE.Vector3(0, 0, 1);
      return this.camera.updateMatrix();
    };

    SalvusThreeJS.prototype.add_lights = function(obj) {
      var fixed, handlers, l, light, m, type, _i, _len, _ref;
      handlers = {
        ambient: this.make_ambient_light,
        directional: this.make_directional_light,
        point: this.make_point_light,
        spot: this.make_spot_light
      };
      this.lights.camera_distance = this.camera.position.distanceTo(this._center);
      _ref = obj.lights;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        l = _ref[_i];
        type = l.light_type;
        delete l.light_type;
        fixed = l.fixed;
        delete l.fixed;
        delete l.type;
        light = handlers[type](l);
        if (fixed === "camera") {
          m = new THREE.Matrix4();
          light.position.applyMatrix4(m.getInverse(this.camera.matrix));
          this.lights.rotating.push(light);
          this.camera.add(light);
        } else {
          this.lights["static"].push(light);
          this.scene.add(light);
        }
      }
      return this.render_scene();
    };

    SalvusThreeJS.prototype.make_ambient_light = function(opts) {
      var o;
      o = defaults(opts, {
        color: 0x444444
      });
      return new THREE.AmbientLight(o.color);
    };

    SalvusThreeJS.prototype.make_directional_light = function(opts) {
      var light, o;
      o = defaults(opts, {
        position: required,
        intensity: 1.0,
        color: 0xffffff
      });
      light = new THREE.DirectionalLight(o.color, o.intensity);
      light.position.set(o.position[0], o.position[1], o.position[2]);
      return light;
    };

    SalvusThreeJS.prototype.make_point_light = function(opts) {
      var light, o;
      o = defaults(opts, {
        position: required,
        intensity: 1.0,
        color: 0xffffff,
        distance: void 0
      });
      light = new THREE.PointLight(o.color, o.intensity, o.distance);
      light.position.set(o.position[0], o.position[1], o.position[2]);
      return light;
    };

    SalvusThreeJS.prototype.make_spot_light = function(opts) {
      var light, o;
      o = defaults(opts, {
        position: required,
        intensity: 1.0,
        color: 0xffffff,
        distance: void 0,
        angle: void 0,
        exponent: void 0
      });
      light = new THREE.SpotLight(o.color, o.intensity, o.distance, o.angle, o.exponent);
      light.position.set(o.position[0], o.position[1], o.position[2]);
      return light;
    };

    SalvusThreeJS.prototype.make_lambert_material = function(opts) {
      var o;
      o = defaults(opts, {
        opacity: 1,
        ambient: 0xffffff,
        diffuse: 0x222222,
        specular: 0xffffff,
        color: required,
        emmissive: 0x222222,
        shininess: 100,
        overdraw: true,
        polygonOffset: true,
        polygonOffsetFactor: 1,
        polygonOffsetUnits: 1,
        side: THREE.DoubleSide
      });
      o.transparent = o.opacity < 1;
      return new THREE.MeshLambertMaterial(o);
    };

    SalvusThreeJS.prototype.make_phong_material = function(opts) {
      var o;
      o = defaults(opts, {
        opacity: 1,
        ambient: 0x222222,
        diffuse: 0x222222,
        specular: 0xffffff,
        color: required,
        emmissive: 0x222222,
        shininess: 100,
        overdraw: true,
        polygonOffset: true,
        polygonOffsetFactor: 1,
        polygonOffsetUnits: 1
      });
      o.transparent = o.opacity < 1;
      return new THREE.MeshPhongMaterial(o);
    };

    SalvusThreeJS.prototype.make_wireframe_material = function() {
      var o;
      o = defaults({}, {
        color: 0x222222,
        transparent: true,
        opacity: .2
      });
      o.wireframe = true;
      return new THREE.MeshBasicMaterial(o);
    };

    SalvusThreeJS.prototype.make_text = function(opts, material) {
      var actualFontSize, canvas, context, font, metrics, o, p, sprite, spriteMaterial, textHeight, textWidth, texture;
      o = defaults(opts, {
        pos: [0, 0, 0],
        string: required,
        fontsize: 14,
        fontface: 'Arial',
        color: "#000000",
        border_thickness: 0,
        constant_size: true
      });
      canvas = document.createElement("canvas");
      context = canvas.getContext("2d");
      textHeight = o.fontsize * 4;
      canvas.height = textHeight;
      font = "Normal " + textHeight + "px " + o.fontface;
      context.font = font;
      metrics = context.measureText(o.string);
      textWidth = metrics.width;
      canvas.width = textWidth;
      context.textAlign = "center";
      context.textBaseline = "middle";
      context.fillStyle = o.color;
      context.font = font;
      context.fillText(o.string, textWidth / 2, textHeight / 2);
      texture = new THREE.Texture(canvas);
      texture.needsUpdate = true;
      spriteMaterial = new THREE.SpriteMaterial({
        map: texture,
        transparent: true
      });
      sprite = new THREE.Sprite(spriteMaterial);
      p = o.pos;
      sprite.position.set(p[0], p[1], p[2]);
      actualFontSize = 0.2;
      sprite.scale.set(textWidth / textHeight * actualFontSize, actualFontSize, 1);
      if (o.constant_size) {
        if (this._text == null) {
          this._text = [sprite];
        } else {
          this._text.push(sprite);
        }
      }
      return sprite;
    };

    SalvusThreeJS.prototype.make_line = function(opts, material) {
      var a, geometry, m, o, _i, _len, _ref;
      o = defaults(opts, {
        points: required,
        thickness: 1,
        arrowhead: false
      });
      m = defaults(material, {
        color: required
      });
      geometry = new THREE.Geometry();
      _ref = o.points;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        a = _ref[_i];
        geometry.vertices.push(new THREE.Vector3(a[0], a[1], a[2]));
      }
      return new THREE.Line(geometry, new THREE.LineBasicMaterial({
        thickness: o.thickness,
        color: m.color
      }));
    };

    SalvusThreeJS.prototype.make_point = function(opts, material) {
      var geometry, m, mesh, o;
      o = defaults(opts, {
        position: [0, 0, 0],
        size: 1
      });
      geometry = new THREE.SphereGeometry(Math.sqrt(o.size) / 50, 8, 8);
      m = this.make_lambert_material(material);
      mesh = new THREE.Mesh(geometry, m);
      mesh.position.set(o.position[0], o.position[1], o.position[2]);
      return mesh;
    };

    SalvusThreeJS.prototype.make_sphere = function(opts, material) {
      var geometry, m1, m2, o;
      o = defaults(opts, {
        radius: 1,
        position: [0, 0, 0]
      });
      geometry = new THREE.SphereGeometry(o.radius, 40, 24);
      m1 = this.make_lambert_material(material);
      m2 = this.make_wireframe_material();
      return THREE.SceneUtils.createMultiMaterialObject(geometry, [m1, m2]);
    };

    SalvusThreeJS.prototype.make_group = function(opts) {
      var i, m, o, obj, _i, _len, _ref;
      o = defaults(opts, {
        matrix: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        children: required
      });
      obj = new THREE.Object3D();
      m = o.matrix;
      obj.matrixAutoUpdate = false;
      obj.matrix.set(m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8], m[9], m[10], m[11], m[12], m[13], m[14], m[15]);
      _ref = o.children;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        i = _ref[_i];
        obj.add(this.make_object(i));
      }
      return obj;
    };

    SalvusThreeJS.prototype.make_index_face_set = function(opts, material) {
      var f, geometry, m1, m2, o, v, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
      o = defaults(opts, {
        vertices: [],
        face3: [],
        face4: [],
        face5: []
      });
      geometry = new THREE.Geometry();
      _ref = opts.vertices;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        geometry.vertices.push(new THREE.Vector3(v[0], v[1], v[2]));
      }
      _ref1 = opts.face3;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        f = _ref1[_j];
        geometry.faces.push(new THREE.Face3(f[0], f[1], f[2]));
      }
      _ref2 = opts.face4;
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        f = _ref2[_k];
        geometry.faces.push(new THREE.Face3(f[0], f[1], f[2]));
        geometry.faces.push(new THREE.Face3(f[0], f[2], f[3]));
      }
      _ref3 = opts.face5;
      for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
        f = _ref3[_l];
        geometry.faces.push(new THREE.Face3(f[0], f[1], f[2]));
        geometry.faces.push(new THREE.Face3(f[0], f[2], f[3]));
        geometry.faces.push(new THREE.Face3(f[0], f[3], f[4]));
      }
      geometry.mergeVertices();
      geometry.computeCentroids();
      geometry.computeFaceNormals();
      geometry.computeVertexNormals();
      geometry.computeBoundingSphere();
      m1 = this.make_lambert_material(material);
      m2 = this.make_wireframe_material();
      return THREE.SceneUtils.createMultiMaterialObject(geometry, [m1, m2]);
    };

    SalvusThreeJS.prototype.make_object = function(obj) {
      var geometry_type, handlers, o, type;
      handlers = {
        text: this.make_text,
        index_face_set: this.make_index_face_set,
        line: this.make_line,
        point: this.make_point,
        sphere: this.make_sphere
      };
      type = obj.type;
      delete obj.type;
      o = false;
      if (type === 'group') {
        o = this.make_group(obj);
      } else if (type === 'object') {
        geometry_type = obj.geometry.type;
        delete obj.geometry.type;
        o = handlers[geometry_type](obj.geometry, obj.texture);
      }
      return o;
    };

    SalvusThreeJS.prototype.add_3dgraphics_obj = function(opts) {
      opts = defaults(opts, {
        obj: required,
        wireframe: false
      });
      this.scene.add(this.make_object(opts.obj));
      return this.render_scene(true);
    };

    SalvusThreeJS.prototype.set_frame = function(opts) {
      var e, eps, geometry, l, material, mx, my, mz, o, offset, txt, v, vertices, x, _i, _len, _ref, _ref1,
        _this = this;
      o = defaults(opts, {
        xmin: required,
        xmax: required,
        ymin: required,
        ymax: required,
        zmin: required,
        zmax: required,
        color: this.opts.foreground,
        thickness: .4,
        labels: true,
        fontsize: 14,
        draw: true
      });
      this._frame_params = o;
      eps = 0.1;
      if (Math.abs(o.xmax - o.xmin) < eps) {
        o.xmax += 1;
        o.xmin -= 1;
      }
      if (Math.abs(o.ymax - o.ymin) < eps) {
        o.ymax += 1;
        o.ymin -= 1;
      }
      if (Math.abs(o.zmax - o.zmin) < eps) {
        o.zmax += 1;
        o.zmin -= 1;
      }
      if (this.frame != null) {
        this.scene.remove(this.frame);
        this.frame = void 0;
      }
      if (o.draw) {
        geometry = new THREE.Geometry();
        vertices = [new THREE.Vector3(o.xmin, o.ymin, o.zmin), new THREE.Vector3(o.xmax, o.ymin, o.zmin), new THREE.Vector3(o.xmax, o.ymax, o.zmin), new THREE.Vector3(o.xmin, o.ymax, o.zmin), new THREE.Vector3(o.xmin, o.ymin, o.zmax), new THREE.Vector3(o.xmax, o.ymin, o.zmax), new THREE.Vector3(o.xmax, o.ymax, o.zmax), new THREE.Vector3(o.xmin, o.ymax, o.zmax)];
        geometry.vertices.push(vertices[0], vertices[1], vertices[1], vertices[2], vertices[2], vertices[3], vertices[3], vertices[0], vertices[4], vertices[5], vertices[5], vertices[6], vertices[6], vertices[7], vertices[7], vertices[4], vertices[0], vertices[4], vertices[1], vertices[5], vertices[2], vertices[6], vertices[3], vertices[7]);
        material = new THREE.LineBasicMaterial({
          color: o.color
        });
        this.frame = new THREE.Line(geometry, material, THREE.LinePieces);
        this.scene.add(this.frame);
      }
      if (o.labels) {
        if (this._frame_labels != null) {
          _ref = this._frame_labels;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            x = _ref[_i];
            this.scene.remove(x);
          }
        }
        this._frame_labels = [];
        l = function(a, b) {
          var z;
          if (b == null) {
            z = a;
          } else {
            z = (a + b) / 2;
          }
          z = z.toFixed(2);
          return (z * 1).toString();
        };
        txt = function(x, y, z, text) {
          var t;
          t = _this.make_text({
            pos: [x, y, z],
            string: text,
            fontsize: o.fontsize,
            color: o.color,
            constant_size: false
          }, {});
          _this._frame_labels.push(t);
          return _this.scene.add(t);
        };
        offset = 0.075;
        mx = (o.xmin + o.xmax) / 2;
        my = (o.ymin + o.ymax) / 2;
        mz = (o.zmin + o.zmax) / 2;
        this._center = new THREE.Vector3(mx, my, mz);
        this.controls.target = this._center;
        if (o.draw) {
          e = (o.ymax - o.ymin) * offset;
          txt(o.xmax, o.ymin - e, o.zmin, l(o.zmin));
          txt(o.xmax, o.ymin - e, mz, "z=" + (l(o.zmin, o.zmax)));
          txt(o.xmax, o.ymin - e, o.zmax, l(o.zmax));
          e = (o.xmax - o.xmin) * offset;
          txt(o.xmax + e, o.ymin, o.zmin, l(o.ymin));
          txt(o.xmax + e, my, o.zmin, "y=" + (l(o.ymin, o.ymax)));
          txt(o.xmax + e, o.ymax, o.zmin, l(o.ymax));
          e = (o.ymax - o.ymin) * offset;
          txt(o.xmax, o.ymax + e, o.zmin, l(o.xmax));
          txt(mx, o.ymax + e, o.zmin, "x=" + (l(o.xmin, o.xmax)));
          txt(o.xmin, o.ymax + e, o.zmin, l(o.xmin));
        }
      }
      v = new THREE.Vector3(mx, my, mz);
      this.camera.lookAt(v);
      this.render_scene();
      if ((_ref1 = this.controls) != null) {
        _ref1.handleResize();
      }
      if (o.draw) {
        return this.render_scene();
      }
    };

    SalvusThreeJS.prototype.animate = function() {
      var _ref;
      if (this._animate) {
        this._animation_frame = requestAnimationFrame(this.animate);
      } else {
        this._animation_frame = false;
      }
      return (_ref = this.controls) != null ? _ref.update() : void 0;
    };

    SalvusThreeJS.prototype.update_rotating_lights = function() {
      var camera_distance, camera_ratio, l, _i, _len, _ref;
      camera_distance = this.camera.position.distanceTo(this._center);
      if (Math.abs(camera_distance - this.lights.camera_distance) > 1e-6) {
        camera_ratio = camera_distance / this.lights.camera_distance;
        _ref = this.lights.rotating;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          l = _ref[_i];
          l.position.setLength(l.position.distanceTo(this._center) * camera_ratio);
        }
        return this.lights.camera_distance = camera_distance;
      }
    };

    SalvusThreeJS.prototype.controlChange = function() {
      if (!this._animation_frame) {
        this._animation_frame = requestAnimationFrame(this.animate);
      }
      this.update_rotating_lights();
      return this.render_scene();
    };

    SalvusThreeJS.prototype.render_scene = function() {
      return this.renderer.render(this.scene, this.camera);
    };

    return SalvusThreeJS;

  })();

  $.fn.salvus_threejs = function(opts) {
    if (opts == null) {
      opts = {};
    }
    return this.each(function() {
      var e, elt;
      elt = $(this);
      e = $(".salvus-3d-templates .salvus-3d-viewer").clone();
      elt.empty().append(e);
      opts.element = e;
      return elt.data('salvus-threejs', new SalvusThreeJS(opts));
    });
  };

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  root.run_when_defined = run_when_defined;

}).call(this);
